
# Hylia — README

> **Curso/Disciplina:** FIAP — 1TDSPO — DDD
> **Solução:** *Hylia* (cadastro de Pacientes, Profissionais e Hospitais)
> **Stack:** Java 17+, Maven, **Quarkus 3.x**, Oracle (JDBC), Agroal (pool), CDI (@Inject)

---

## Sumário

1. Objetivo & Escopo
2. Arquitetura & Pastas
3. Regras de Negócio
4. DDL
5. Configuração & Execução
6. Como testar (runner)
7. Por que usamos @Inject / Beans

---

## Objetivo & Escopo

**Hylia** é um projeto didático demonstrando **Clean Architecture** com **Quarkus** e **Oracle**.
Nesta entrega:

* Domínio com entidades: **Paciente**, **Professional**, **Hospital**.
* **Validações de domínio** (CPF/CRM/Email/UF/Idade) e normalização de dados.
* Persistência **JDBC** (Oracle) via **Agroal DataSource** (pool).
* Execução em **modo runner/CLI** (sem API REST por enquanto).

**Fora do escopo**: autenticação/autorização, interface web, agendamentos, integrações externas.

---

## Arquitetura & Pastas

**Clean Architecture**: regras de negócio no **domínio**, persistência isolada na **infraestrutura**, acoplamento via **interfaces de repositório** (Dependency Inversion).

```
src/main/java/br/com/fiap/hylia
├─ domain
│  ├─ model        
│  ├─ repository   
│  ├─ util         
│  └─ exceptions   
├─ infrastructure
│  ├─ persistence  
│  └─ main         
└─ resources
   └─ application.properties
```

**Fluxo (ex.: salvar Paciente):**
Runner cria entidade → chama `PacienteRepository` (interface do **domínio**) → CDI injeta `JdbcPacienteRepository` (**infra**) → executa SQL usando `DatabaseConnectionImpl` (que injeta `DataSource` Agroal) → retorna a entidade com `id`.

---

## Regras de Negócio

### Paciente

* **CPF válido**, **nome normalizado**, **idade 0..120**.
* Atualização consistente de nome/idade (ex.: evitar “voltar” idade de forma incoerente).

### Professional

* **CRM** (formato canônico, ex.: `CRM-1234`, armazenado **UPPER**), **CPF válido**, **email válido** (armazenado **lowercase**), **idade ≥ 23**.
* Atualização de perfil (nome, idade, email, especialidade).
* **Identidade por CRM** (`equals/hashCode` baseados em CRM).

### Hospital

* **UF** com 2 letras (ex.: `SP`), **email válido**.
* Atualização de dados (nome, cidade, estado, email).

### Exceções

* **ValidacaoDominioException**: violação de regra de negócio (lançada nas entidades).
* **EntidadeNaoLocalizada**: quando o repositório não encontra o registro.
* **Erros SQL**: tratados na borda de infraestrutura (JDBC).

---

## DDL

```sql
-- PACIENTE
CREATE TABLE PACIENTE (
  ID         NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  CPF        VARCHAR2(14)  NOT NULL,
  NOME       VARCHAR2(120) NOT NULL,
  IDADE      NUMBER(3)     NOT NULL,
  CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP,
  UPDATED_AT TIMESTAMP
);
ALTER TABLE PACIENTE ADD CONSTRAINT UQ_PACIENTE_CPF UNIQUE (CPF);

-- PROFESSIONAL
CREATE TABLE PROFESSIONAL (
  ID            NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  CRM           VARCHAR2(32)  NOT NULL,
  CPF           VARCHAR2(14)  NOT NULL,
  NOME          VARCHAR2(120) NOT NULL,
  IDADE         NUMBER(3)     NOT NULL,
  EMAIL         VARCHAR2(160) NOT NULL,
  ESPECIALIDADE VARCHAR2(160) NOT NULL,
  CREATED_AT    TIMESTAMP DEFAULT SYSTIMESTAMP,
  UPDATED_AT    TIMESTAMP
);
ALTER TABLE PROFESSIONAL ADD CONSTRAINT UQ_PROFESSIONAL_CRM   UNIQUE (CRM);
ALTER TABLE PROFESSIONAL ADD CONSTRAINT UQ_PROFESSIONAL_EMAIL UNIQUE (EMAIL);

-- HOSPITAL
CREATE TABLE HOSPITAL (
  ID         NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  NOME       VARCHAR2(160) NOT NULL,
  CIDADE     VARCHAR2(120) NOT NULL,
  ESTADO     CHAR(2)       NOT NULL,
  EMAIL      VARCHAR2(160) NOT NULL,
  CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP,
  UPDATED_AT TIMESTAMP
);
ALTER TABLE HOSPITAL ADD CONSTRAINT UQ_HOSPITAL_EMAIL UNIQUE (EMAIL);
```

> **Evolução (opcional para trabalhos futuros):**
> A) `PROFESSIONAL.HOSPITAL_ID` (FK → `HOSPITAL.ID`) para relação “trabalha em”.
> B) Tabela **AGENDAMENTO** relacionando `PACIENTE`, `PROFESSIONAL`, `HOSPITAL`.

---

## Configuração & Execução

### Requisitos

* **Java JDK 17+**, **Maven 3.9+**
* Banco **Oracle** acessível
* IDE sugerida: IntelliJ IDEA

### Dependências (pom principais)

* `io.quarkus:quarkus-agroal` (pool/datasource)
* `io.quarkus:quarkus-jdbc-oracle` (driver)
* `io.quarkus:quarkus-arc` (CDI)
* `io.quarkus:quarkus-junit5` (testes)

### Configurar datasource — `src/main/resources/application.properties`

```properties
quarkus.datasource.db-kind=oracle
quarkus.datasource.jdbc.url=jdbc:oracle:thin:@<host>:<port>:<SID>
quarkus.datasource.username=RM561408
quarkus.datasource.password=171192
```

---

## Como testar (runner)

**Classe:** `br.com.fiap.hylia.infrastructure.main.HyliaApplication`
* Rodar a classe Main via IDE.
* Demonstra **create → update → find** para **Paciente**, **Professional** e **Hospital**.
* Para facilitar reexecuções, existe um **pre-clean** que remove registros pelos identificadores padrão (**CPF/CRM/EMAIL**) antes de criar novamente.
* Para **apagar** via runner, **descomente** os blocos `delete...()` e rode novamente.
* Para **testar outros dados**, altere as **variáveis** no topo da classe HyliaApplication (ex.: `P_CPF`, `PRO_CRM`, `H_EMAIL` test data).

**Verificar no banco (exemplos):**

```sql
SELECT * FROM PACIENTE     WHERE CPF   = '123.456.789-09';
SELECT * FROM PROFESSIONAL WHERE CRM   = 'CRM-1234';
SELECT * FROM HOSPITAL     WHERE EMAIL = 'hospital@demo.com';
```

---

## Por que usamos @Inject / Beans

* **CDI (Quarkus/Arc)** fornece **injeção de dependências**: o container cria/gerencia instâncias (`@ApplicationScoped`), resolve dependências (`@Inject`) e cuida do *wiring* (menos *boilerplate*).
* **Inversão de dependência**: a aplicação depende **de interfaces** do domínio (`PacienteRepository`), e a **infraestrutura** oferece implementações (`JdbcPacienteRepository`) que o CDI injeta.
* **Testabilidade e troca de implementação**: é simples mockar/stubbar repositórios, ou trocar JDBC por JPA no futuro sem tocar o domínio.
* **Agroal DataSource**: Quarkus expõe o pool; injetamos `DataSource` e abrimos `Connection` em `DatabaseConnectionImpl` — sem gerenciar conexões manualmente.

> Usamos CDI/@Inject para manter o domínio desacoplado da infraestrutura, facilitar testes/mocks e delegar o *wiring* ao container do Quarkus.
